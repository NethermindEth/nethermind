// SPDX-FileCopyrightText: 2025 Demerzel Solutions Limited
// SPDX-License-Identifier: LGPL-3.0-only

namespace Nethermind.Verkle.Tree;

// SPDX-FileCopyrightText: 2023 Demerzel Solutions Limited
// SPDX-License-Identifier: LGPL-3.0-only

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Linq;
using System.Runtime.Intrinsics;

using Nethermind.Core.Attributes;
using Nethermind.Core.Crypto;
using Nethermind.Core.Extensions;
using System.Numerics;


/// <summary>
/// Patricia trie tree path. Can represent up to 64 nibbles in 32+4 bytes.
/// Can be used as ref struct and mutated during trie traversal.
/// </summary>
[Todo("check if its worth it to change the length to byte, or if it actually make things slower.")]
[Todo("check if its worth it to not clear byte during TruncateMut, but will need proper comparator, span copy, etc.")]
public struct VerklePath : IEquatable<VerklePath>
{
    public const int MemorySize = 36;
    public ValueHash256 Path;

    public static VerklePath Empty => new();

    public readonly Span<byte> Span => Path.BytesAsSpan;

    public VerklePath(in ValueHash256 path, int length)
    {
        if (length > 32) throw new InvalidOperationException("VerklePath can't represent more than 32 bytes.");
        Path = path;
        Length = length;
    }

    public int Length { get; private set; }

    public readonly byte this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Span[index];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => Span[index] = value;
    }

    public static VerklePath FromPath(ReadOnlySpan<byte> pathHash)
    {
        if (pathHash.Length > 32) throw new InvalidOperationException("Path must be at most 32 byte");
        if (pathHash.Length == 32) return new VerklePath(new ValueHash256(pathHash), 32);

        // Some of the test passes path directly to PatriciaTrie, but its not 32 byte.
        VerklePath newVerklePath = new();
        pathHash.CopyTo(newVerklePath.Span);
        newVerklePath.Length = pathHash.Length;
        return newVerklePath;
    }

    // Mainly used in testing code
    public static VerklePath FromHexString(string hexString)
    {
        string toHashHex = hexString;
        if (hexString.Length < 64)
        {
            toHashHex += string.Concat(Enumerable.Repeat('0', 64 - hexString.Length));
        }
        return new VerklePath(new ValueHash256(toHashHex), hexString.Length/2);
    }

    public readonly VerklePath Append(ReadOnlySpan<byte> nibbles)
    {
        if (nibbles.Length == 0) return this;
        if (nibbles.Length == 1) return Append(nibbles[0]);

        VerklePath copy = this;
        copy.AppendMut(nibbles);
        return copy;
    }

    public readonly VerklePath Append(byte nib)
    {
        VerklePath copy = this;
        copy.AppendMut(nib);
        return copy;
    }

    public readonly VerklePath Append(byte nib, int repeat)
    {
        VerklePath copy = this;
        for (int i = 0; i < repeat; i++) copy.AppendMut(nib);
        return copy;
    }

    internal void AppendMut(ReadOnlySpan<byte> bytes)
    {
        if (bytes.Length == 0) return;
        if (bytes.Length == 1)
        {
            AppendMut(bytes[0]);
            return;
        }

        bytes.CopyTo(Span[Length..]);
        Length += bytes.Length;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AppendMut(byte nib)
    {
        Span[Length] = nib;
        Length++;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetLast(byte nib)
    {
        Span[Length - 1] = nib;
    }

    public readonly VerklePath Truncate(int pathLength)
    {
        VerklePath copy = this;
        copy.TruncateMut(pathLength);
        return copy;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TruncateMut(int pathLength)
    {
        if (pathLength == Length) return;
        ReadOnlySpan<Vector256<byte>> zeroMasks = MemoryMarshal.CreateReadOnlySpan(ref Unsafe.As<byte, Vector256<byte>>(ref MemoryMarshal.GetReference(ZeroMasksData)), ZeroMasksData.Length / Vector256<byte>.Count);
        // We additionally check against the array length even it will never be larger
        // however it helps the JIT to optimize the bounds check away, and in this case
        // the JIT will create two paths based on length, a throwing and a non-throwing one
        // which expands the code size significantly and can be avoided by this check.
        if (pathLength > Length || (uint)pathLength >= (uint)zeroMasks.Length)
        {
            ThrowPathMustBeLess();
        }

        Unsafe.As<ValueHash256, Vector256<byte>>(ref Path) &= zeroMasks[pathLength];

        Length = pathLength;

        [DoesNotReturn]
        [StackTraceHidden]
        static void ThrowPathMustBeLess()
        {
            throw new IndexOutOfRangeException("path length must be less than current length");
        }
    }

    /// <summary>
    /// Truncate just one. Used for Branch, which is a hot code path.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TruncateOne()
    {
        Span[Length - 1] = 0;
        Length--;
    }

    public readonly string ToHexString()
    {
        string fromPath = Span.ToHexString();
        return fromPath[..(Length * 2)];
    }

    public readonly ReadOnlySpan<byte> ToPath()
    {
        return Span[..Length];
    }

    public readonly override string ToString()
    {
        return ToHexString();
    }

    public static bool operator ==(in VerklePath left, in VerklePath right)
    {
        return left.Equals(right);
    }

    public static bool operator !=(in VerklePath left, in VerklePath right)
    {
        return !(left == right);
    }

    public readonly bool Equals(in VerklePath other)
    {
        return Length == other.Length && Path.Equals(in other.Path);
    }

    public readonly bool Equals(VerklePath other) => Equals(in other);

    public readonly override bool Equals(object? obj)
    {
        return obj is VerklePath other && Equals(in other);
    }

    public readonly override int GetHashCode()
    {
        return (int)BitOperations.Crc32C((uint)Path.GetHashCode(), (uint)Length);
    }

    /// <summary>
    /// Used for scoped pattern where inside the scope the path is appended with some nibbles and it will
    /// truncate back to previous length on dispose. Cut down on memory allocations.
    /// </summary>
    public ref struct AppendScope
    {
        private readonly int _previousLength;
        private ref VerklePath _path;

        public AppendScope(int previousLength, ref VerklePath path)
        {
            _previousLength = previousLength;
            _path = ref path;
        }

        public void Dispose()
        {
            _path.TruncateMut(_previousLength);
        }
    }

    public readonly int CompareTo(in VerklePath otherTree)
    {
        int commonByteLength = Math.Min(Length, otherTree.Length);
        int compareByByte =
            Bytes.BytesComparer.Compare(Span[..commonByteLength], otherTree.Span[..commonByteLength]);
        if (compareByByte != 0) return compareByByte;

        return Length.CompareTo(otherTree.Length);
    }

    /// <summary>
    /// Compare with otherTree, as if this VerklePath was truncated to `length`.
    /// </summary>
    /// <param name="otherTree"></param>
    /// <param name="length"></param>
    /// <returns></returns>
    public readonly int CompareToTruncated(in VerklePath otherTree, int length)
    {
        int commonByteLength = Math.Min(length, otherTree.Length);
        int compareByByte =
            Bytes.BytesComparer.Compare(Span[..commonByteLength], otherTree.Span[..commonByteLength]);
        if (compareByByte != 0) return compareByByte;

        return length.CompareTo(otherTree.Length);
    }

    private static ReadOnlySpan<byte> ZeroMasksData =>
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00
    ];

    public bool StartsWith(VerklePath otherPath)
    {
        return Truncate(otherPath.Length) == otherPath;
    }
}

public static class VerklePathExtensions
{
    public static VerklePath.AppendScope ScopedAppend(this ref VerklePath path, Span<byte> nibbles)
    {
        int previousLength = path.Length;
        path.AppendMut(nibbles);
        return new VerklePath.AppendScope(previousLength, ref path);
    }
}
