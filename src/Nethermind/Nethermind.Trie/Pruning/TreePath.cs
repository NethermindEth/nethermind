// SPDX-FileCopyrightText: 2023 Demerzel Solutions Limited
// SPDX-License-Identifier: LGPL-3.0-only

using System;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Linq;
using System.Runtime.Intrinsics;

using Nethermind.Core.Attributes;
using Nethermind.Core.Crypto;
using Nethermind.Core.Extensions;
using System.Numerics;

namespace Nethermind.Trie;

/// <summary>
/// Patricia trie tree path. Can represent up to 64 nibbles in 32+4 byte.
/// Can be used as ref struct, and mutated during trie traversal.
/// </summary>
[Todo("check if its worth it to change the length to byte, or if it actually make things slower.")]
[Todo("check if its worth it to not clear byte during TruncateMut, but will need proper comparator, span copy, etc.")]
public struct TreePath : IEquatable<TreePath>
{
    public const int MemorySize = 36;
    public const int MaxLength = 64;
    public ValueHash256 Path;

    public static TreePath Empty => new();

    public readonly Span<byte> Span => Path.BytesAsSpan;

    public TreePath(in ValueHash256 path, int length)
    {
        if (length > 64) throw new InvalidOperationException("TreePath can't represent more than 64 nibble.");
        Path = path;
        Length = length;
    }

    public int Length { get; private set; }
    private bool IsOdd => Length % 2 == 1;

    public static TreePath FromPath(ReadOnlySpan<byte> pathHash)
    {
        if (pathHash.Length > 32) throw new InvalidOperationException("Path must be at most 32 byte");
        if (pathHash.Length == 32) return new TreePath(new ValueHash256(pathHash), 64);

        // Some of the test passes path directly to PatriciaTrie, but its not 32 byte.
        TreePath newTreePath = new();
        pathHash.CopyTo(newTreePath.Span);
        newTreePath.Length = pathHash.Length * 2;
        return newTreePath;
    }

    // Mainly used in testing code
    public static TreePath FromHexString(string hexString)
    {
        string toHashHex = hexString;
        if (hexString.Length < 64)
        {
            toHashHex += string.Concat(Enumerable.Repeat('0', 64 - hexString.Length));
        }
        return new TreePath(new ValueHash256(toHashHex), hexString.Length);
    }

    public static TreePath FromNibble(ReadOnlySpan<byte> pathNibbles)
    {
        if (pathNibbles.Length > 64) throw new InvalidOperationException($"Nibble length too long: {pathNibbles.Length}. Max is 64");
        ValueHash256 hash = Keccak.Zero;
        ToBytesExtra(pathNibbles, hash.BytesAsSpan);

        return new TreePath(hash, pathNibbles.Length);
    }

    public static (TreePath key, bool isLeaf) FromHexPrefix(ReadOnlySpan<byte> bytes)
    {
        // TODO: Bound check
        bool isEven = (bytes[0] & 16) == 0;
        int nibblesCount = bytes.Length * 2 - (isEven ? 2 : 1);
        bool isLeaf = bytes[0] >= 32;

        TreePath treePath = new TreePath();
        if (isEven)
        {
            bytes[1..].CopyTo(treePath.Span);
        }
        else
        {
            bytes.CopyTo(treePath.Span);
            ShiftLeft4BitMut(treePath.Span);
        }
        treePath.Length = nibblesCount;

        return (treePath, isLeaf);
    }

    private static void ToBytesExtra(ReadOnlySpan<byte> nibbles, Span<byte> bytes)
    {
        for (int i = 0; i < nibbles.Length / 2; i++)
        {
            bytes[i] = Nibbles.ToByte(nibbles[2 * i], nibbles[2 * i + 1]);
        }

        if (nibbles.Length % 2 == 1)
        {
            bytes[nibbles.Length / 2] = Nibbles.ToByte(nibbles[^1], 0);
        }
    }

    public readonly TreePath Append(ReadOnlySpan<byte> nibbles)
    {
        if (nibbles.Length == 0) return this;
        if (nibbles.Length == 1) return Append(nibbles[0]);

        TreePath copy = this;
        copy.AppendMut(nibbles);
        return copy;
    }

    public readonly TreePath Append(int nib)
    {
        TreePath copy = this;
        copy.AppendMut(nib);
        return copy;
    }

    public readonly TreePath Append(int nib, int repeat)
    {
        TreePath copy = this;
        for (int i = 0; i < repeat; i++) copy.AppendMut(nib);
        return copy;
    }

    internal void AppendMut(ReadOnlySpan<byte> nibbles)
    {
        if (nibbles.Length == 0) return;
        if (nibbles.Length == 1)
        {
            AppendMut(nibbles[0]);
            return;
        }

        Span<byte> pathSpan = Span;

        if (Length % 2 == 1)
        {
            this[Length] = nibbles[0];
            Length++;
            nibbles = nibbles[1..];
        }

        int byteLength = nibbles.Length / 2;
        int pathSpanStart = Length / 2;
        for (int i = 0; i < byteLength; i++)
        {
            pathSpan[i + pathSpanStart] = Nibbles.ToByte(nibbles[i * 2], nibbles[i * 2 + 1]);
            Length += 2;
        }

        if (nibbles.Length % 2 == 1)
        {
            this[Length] = nibbles[^1];
            Length++;
        }
    }

    internal void AppendMut(TreePath otherPath)
    {
        if (otherPath.Length == 0) return;
        if (otherPath.Length + Length > MaxLength) throw new InvalidOperationException($"TreePath only have a maximimum length of 64 nibble. Trying to append {Length} with another tree path of length {otherPath.Length}.");

        if (IsOdd)
        {
            AppendMut(otherPath[0]);
            ShiftLeft4BitMut(otherPath.Span);
            otherPath.Length--;
        }

        int byteToCopy = otherPath.Length / 2;

        otherPath.Span[..byteToCopy].CopyTo(Span[(Length/2)..]);
        Length += byteToCopy * 2;

        if (otherPath.IsOdd)
        {
            AppendMut(otherPath[^1]);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AppendMut(int nib)
    {
        this[Length] = nib;
        Length++;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetLast(int nib)
    {
        this[Length - 1] = nib;
    }

    public readonly int this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            int offset = index / 2;
            Span<byte> theSpan = Span;
            int b = theSpan[offset];
            if ((index & 1) == 0)
            {
                return ((b & 0xf0) >> 4);
            }
            else
            {
                return (b & 0x0f);
            }
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            int offset = index / 2;
            Span<byte> theSpan = Span;
            ref byte b = ref theSpan[offset];
            if ((index & 1) == 0)
            {
                b = (byte)((b & 0x0f) | (value & 0x0f) << 4);
            }
            else
            {
                b = (byte)((b & 0xf0) | ((value & 0x0f)));
            }
        }
    }

    public readonly TreePath Truncate(int pathLength)
    {
        TreePath copy = this;
        copy.TruncateMut(pathLength);
        return copy;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TruncateMut(int pathLength)
    {
        if (pathLength == Length) return;
        ReadOnlySpan<Vector256<byte>> zeroMasks = MemoryMarshal.CreateReadOnlySpan(ref Unsafe.As<byte, Vector256<byte>>(ref MemoryMarshal.GetReference(ZeroMasksData)), ZeroMasksData.Length / Vector256<byte>.Count);
        // We additionally check against the array length even it will never be larger
        // however it helps the JIT to optimize the bounds check away, and in this case
        // the JIT will create two paths based on length, a throwing and a non-throwing one
        // which expands the code size significantly and can be avoided by this check.
        if (pathLength > Length || (uint)pathLength >= (uint)zeroMasks.Length)
        {
            ThrowPathMustBeLess();
        }

        Unsafe.As<ValueHash256, Vector256<byte>>(ref Path) &= zeroMasks[pathLength];

        Length = pathLength;

        [DoesNotReturn]
        [StackTraceHidden]
        static void ThrowPathMustBeLess()
        {
            throw new IndexOutOfRangeException("path length must be less than current length");
        }
    }

    /// <summary>
    /// Truncate just one. Used for Branch, which is a hot code path.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TruncateOne()
    {
        this[Length - 1] = 0;
        Length--;
    }

    public readonly byte[] ToNibble()
    {
        bool odd = Length % 2 == 1;
        Span<byte> theNibbles = stackalloc byte[odd ? Length + 1 : Length];
        Nibbles.BytesToNibbleBytes(Span[..((Length + 1) / 2)], theNibbles);
        return (odd ? theNibbles[..Length] : theNibbles).ToArray();
    }

    public readonly string ToHexString()
    {
        string fromPath = Span.ToHexString();
        return fromPath[..Length];
    }

    public readonly override string ToString()
    {
        return ToHexString();
    }

    public TreePath this[Range range]
    {
        get
        {
            (int offset, int length) = range.GetOffsetAndLength(Length);
            return Slice(offset, length);
        }
    }

    public static bool operator ==(in TreePath left, in TreePath right)
    {
        return left.Equals(right);
    }

    public static bool operator !=(in TreePath left, in TreePath right)
    {
        return !(left == right);
    }

    public readonly bool Equals(in TreePath other)
    {
        return Length == other.Length && Path.Equals(in other.Path);
    }

    public readonly bool Equals(TreePath other) => Equals(in other);

    public readonly override bool Equals(object? obj)
    {
        return obj is TreePath other && Equals(in other);
    }

    public readonly override int GetHashCode()
    {
        return (int)BitOperations.Crc32C((uint)Path.GetHashCode(), (uint)Length);
    }

    /// <summary>
    /// Used for scoped pattern where inside the scope the path is appended with some nibbles and it will
    /// truncate back to previous length on dispose. Cut down on memory allocations.
    /// </summary>
    public ref struct AppendScope
    {
        private readonly int _previousLength;
        private ref TreePath _path;

        public AppendScope(int previousLength, ref TreePath path)
        {
            _previousLength = previousLength;
            _path = ref path;
        }

        public void Dispose()
        {
            _path.TruncateMut(_previousLength);
        }
    }

    public readonly int CompareTo(in TreePath otherTree)
    {
        int minLength = Math.Min(Length, otherTree.Length);
        int commonByteLength = minLength / 2;
        int compareByByte =
            Bytes.BytesComparer.Compare(Span[..commonByteLength], otherTree.Span[..commonByteLength]);
        if (compareByByte != 0) return compareByByte;

        if (minLength % 2 == 1)
        {
            int result = this[minLength - 1].CompareTo(otherTree[minLength - 1]);
            if (result != 0) return result;
        }

        return Length.CompareTo(otherTree.Length);
    }

    /// <summary>
    /// Compare with otherTree, as if this TreePath was truncated to `length`.
    /// </summary>
    /// <param name="otherTree"></param>
    /// <param name="length"></param>
    /// <returns></returns>
    public readonly int CompareToTruncated(in TreePath otherTree, int length)
    {
        int minLength = Math.Min(length, otherTree.Length);
        int commonByteLength = minLength / 2;
        int compareByByte =
            Bytes.BytesComparer.Compare(Span[..commonByteLength], otherTree.Span[..commonByteLength]);
        if (compareByByte != 0) return compareByByte;

        if (minLength % 2 == 1)
        {
            int result = this[minLength - 1].CompareTo(otherTree[minLength - 1]);
            if (result != 0) return result;
        }

        return length.CompareTo(otherTree.Length);
    }

    private static ReadOnlySpan<byte> ZeroMasksData => new byte[]
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
    };

    public bool StartsWith(TreePath otherPath)
    {
        return Truncate(otherPath.Length) == otherPath;
    }

    public TreePath Prepend(int nib)
    {
        TreePath path = new TreePath();
        path.AppendMut(nib);
        path.AppendMut(this);
        return path;
    }

    public TreePath Append(TreePath otherPath)
    {
        TreePath path = this;
        path.AppendMut(otherPath);
        return path;
    }

    [MethodImpl(MethodImplOptions.AggressiveOptimization | MethodImplOptions.AggressiveInlining)]
    public readonly TreePath Slice(int from, int count)
    {
        // TODO: Check bound

        TreePath path = this;
        if (from % 2 == 1)
        {
            ShiftLeft4BitMut(path.Span);
            from--;
        }

        if (from == 0)
        {
            path.TruncateMut(count);
            return path;
        }

        TreePath path2 = Empty;
        int spanCount = count / 2;
        int spanOff = from / 2;
        path.Span[spanOff..(spanOff + spanCount)].CopyTo(path2.Span);

        // Last nib
        if (count % 2 == 1)
        {
            path2[count - 1] = path[from + count - 1];
        }

        path2.Length = count;
        return path2;
    }

    public static void ShiftLeft4BitMut(Span<byte> byteSpan)
    {
        for (int i = 0; i < 4; i++)
        {
            ulong asLong = BinaryPrimitives.ReadUInt64BigEndian(byteSpan[(i*8)..]);
            asLong <<= 4;
            if (i < 3)
            {
#pragma warning disable CS0675 // Bitwise-or operator used on a sign-extended operand
                byte asByte = byteSpan[(i*8) + 8];
                asLong |= (ulong)(asByte >> 4);
#pragma warning restore CS0675 // Bitwise-or operator used on a sign-extended operand
            }
            BinaryPrimitives.WriteUInt64BigEndian(byteSpan[(i*8)..], asLong);
        }
    }

    public int CommonPrefixLength(TreePath otherPath)
    {
        Span<byte> span1 = Span;
        Span<byte> span2 = otherPath.Span;
        int commonLength = span1.CommonPrefixLength(span2);
        int result = 0;
        if (commonLength == 32)
        {
            result = 64; // All same
        }
        else
        {
            result = commonLength * 2;
            if (this[result] == otherPath[result])
            {
                result++;
            }
        }

        return Math.Min(result, Math.Min(otherPath.Length, Length));
    }

    public void ToHexPrefixSpan(bool isLeaf, Span<byte> output)
    {
        if (output.Length != HexPrefix.ByteLength(Length)) throw new ArgumentOutOfRangeException(nameof(output));

        output[0] = (byte)(isLeaf ? 0x20 : 0x00);
        if (Length % 2 != 0)
        {
            output[0] += (byte)(0x10 + this[0]);
            TreePath copy = this;
            ShiftLeft4BitMut(Span);
            int toCopyByte = Length / 2;
            copy.Span[..toCopyByte].CopyTo(output[1..]);
        }
        else
        {
            int toCopyByte = Length / 2;
            Span[..toCopyByte].CopyTo(output[1..]);
        }
    }
}

public static class TreePathExtensions
{
    public static TreePath.AppendScope ScopedAppend(this ref TreePath path, Span<byte> nibbles)
    {
        int previousLength = path.Length;
        path.AppendMut(nibbles);
        return new TreePath.AppendScope(previousLength, ref path);
    }

    public static TreePath.AppendScope ScopedAppend(this ref TreePath path, TreePath otherPath)
    {
        int previousLength = path.Length;
        path.AppendMut(otherPath);
        return new TreePath.AppendScope(previousLength, ref path);
    }
}
