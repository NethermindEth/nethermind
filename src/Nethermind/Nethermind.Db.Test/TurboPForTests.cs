// SPDX-FileCopyrightText: 2025 Demerzel Solutions Limited
// SPDX-License-Identifier: LGPL-3.0-only

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using NUnit.Framework;

namespace Nethermind.Db.Test;

// More for documenting how the library works and comparing compression sizes
public class TurboPForTests
{
    private static IEnumerable<int> Lengths()
    {
        yield return 1;
        yield return 10;

        for (var i = 32; i <= 1024; i <<= 1)
        {
            yield return i - 1;
            yield return i;
            yield return i + 1;
        }
    }

    private static IEnumerable<int> Deltas()
    {
        yield return 10;
        yield return 20;
        yield return 50;
        yield return 100;
        yield return 1000;
    }

    [TestCaseSource(nameof(Lengths))]
    public unsafe void p4nd1enc256v32_Increasing_Consecutive(int length)
    {
        var values = Enumerable.Range(0, length).ToArray();
        var compressed = Compress(values, TurboPFor.p4nd1enc256v32);
        var decompressed = Decompress(compressed, values.Length, TurboPFor.p4nd1dec256v32);

        Assert.That(decompressed, Is.EquivalentTo(values));
    }

    [TestCaseSource(nameof(Lengths))]
    public unsafe void p4nd1enc128v32_Increasing_Consecutive(int length)
    {
        var values = Enumerable.Range(0, length).ToArray();
        var compressed = Compress(values, TurboPFor.p4nd1enc128v32);
        var decompressed = Decompress(compressed, values.Length, TurboPFor.p4nd1dec128v32);

        Assert.That(decompressed, Is.EquivalentTo(values));
    }

    [Combinatorial]
    public unsafe void p4nd1enc256v32_Increasing_Random(
        [ValueSource(nameof(Lengths))] int length,
        [ValueSource(nameof(Deltas))] int maxDelta
    )
    {
        var values = RandomIncreasingRange(new(42), length, maxDelta).ToArray();
        var compressed = Compress(values, TurboPFor.p4nd1enc256v32);
        var decompressed = Decompress(compressed, values.Length, TurboPFor.p4nd1dec256v32);

        Assert.That(decompressed, Is.EquivalentTo(values));
    }

    [Combinatorial]
    public unsafe void p4nd1enc128v32_Increasing_Random(
        [ValueSource(nameof(Lengths))] int length,
        [ValueSource(nameof(Deltas))] int maxDelta
    )
    {
        var values = RandomIncreasingRange(new(42), length, maxDelta).ToArray();
        var compressed = Compress(values, TurboPFor.p4nd1enc128v32);
        var decompressed = Decompress(compressed, values.Length, TurboPFor.p4nd1dec128v32);

        Assert.That(decompressed, Is.EquivalentTo(values));
    }

    [TestCaseSource(nameof(Lengths))]
    public unsafe void p4nd1enc256v32_Increasing_Consecutive_Negative(int length)
    {
        var values = Enumerable.Range(0, length).Reverse().Select(x => -x).ToArray();
        var compressed = Compress(values, TurboPFor.p4nd1enc256v32);
        var decompressed = Decompress(compressed, values.Length, TurboPFor.p4nd1dec256v32);

        Assert.That(decompressed, Is.EquivalentTo(values));
    }

    [TestCaseSource(nameof(Lengths))]
    public unsafe void p4nd1enc256v32_Decreasing_Consecutive(int length)
    {
        var values = Enumerable.Range(0, length).Reverse().ToArray();
        var compressed = Compress(values, TurboPFor.p4nd1enc256v32);
        var decompressed = Decompress(compressed, values.Length, TurboPFor.p4nd1dec256v32);

        Assert.That(decompressed, Is.EquivalentTo(values));
    }

    [Combinatorial]
    public unsafe void p4nd1enc256v32_Increasing_Random_Negative(
        [ValueSource(nameof(Lengths))] int length,
        [ValueSource(nameof(Deltas))] int maxDelta
    )
    {
        var values = RandomIncreasingRange(new(42), length, maxDelta).Reverse().Select(x => -x).ToArray();
        var compressed = Compress(values, TurboPFor.p4nd1enc256v32);
        var decompressed = Decompress(compressed, values.Length, TurboPFor.p4nd1dec256v32);

        Assert.That(decompressed, Is.EquivalentTo(values));
    }

    [Combinatorial]
    public unsafe void p4nd1enc256v32_Decreasing_Random(
        [ValueSource(nameof(Lengths))] int length,
        [ValueSource(nameof(Deltas))] int maxDelta
    )
    {
        var values = RandomIncreasingRange(new(42), length, maxDelta).Reverse().ToArray();
        var compressed = Compress(values, TurboPFor.p4nd1enc256v32);
        var decompressed = Decompress(compressed, values.Length, TurboPFor.p4nd1dec256v32);

        Assert.That(decompressed, Is.EquivalentTo(values));
    }

    [Test, Repeat(10)]
    public unsafe void p4nd1dec256v32_Crash_Test()
    {
        (byte[], int) val = (
            Convert.FromHexString("E27AF7724204075E5608000791052180412711D000005112150504001050114072C8400058161114000011003022502010844550051801204100014000110002001142004120FF01000000010000000100000002000000465B67698003542783E0DC71605DDDFA31030160101021004320A389400BCE008E400235960161922C49924869928989122591922DD1124592924C51B22C5AA4448A962451926480031310055028008060452100402001227701064C8402612100020281702264008289A22449922449922651942589A2484A9228499424398003E1C7D1844365145021CC4692CBCFBCC867D40E9D4102ABA6B2892E100B0D8C0D49A2245393244E942849A228EB232514B3484AB8585232854B26455214AD62955191B2454A322689A228800343199946028D2166B42A80E2741CDD024706ADD41A4D6744337ED5010A0264448B982889926449968449C62461122A4B92AD49242551A22489A42B51922489223149962949A22880032015932102430A1889450BE89857665587B5FC851B1EC077EEE720F33232120AC9B42889942861982849A44451B664C9A27049B644C9322D1197246192249BC24E89142E899428519228420245849200009180000506554101161100050075000400104980239D209620441111C080040504150540240012000000010400906705000200010100A040001408FF010000000200000063ED80038A03D0757971F3CD54D60A554FB6829A02529020B6108535104250801020A0D04AA22C8EA25489C26449962C51A2289192C861A2489916258B1225D192244A92284C1225800388D8A001210102802000090A689842210200020094409D69050C489E18B03AAA8912454992644992244912294CA6249192244B122549922C91948003C9130111C50E144209A50000A002200104004800101302A0D8122D22402904015B94440A9726899224CA92244992244A944489922449028002004A800183018C870902C70000A014C23050264C00008644000346840044092265565666665D65555555955555555580030084A420420D4000100000328A1828243082303466800BB634040000140084004BA44489A23449942451142D4A12494B924C8992244105A051090210800000019010808001040800841C8011020185A0005800000A0003FF01000000010000000100000001000000010000002F4A95A4F9800301060020100000040018380F011208091400C1082CD620908BE7088434340404C9922452164D4992244922254992288B932449A24449008002892D000044005414A9008040000149000E0418180A0000808A686902002000006557595657557555969555558003406040000048221750000018001856D12F1800160C90008A020010400800040151924449922449922489224691926449A224498002048410B00181EC5C83980C0401219681D748A200978000020488040908109088556595575676555956565555596565A9554107010000093450089800400100A880082040420430200000860000001000010040FF010000000100000001000000010000000100000001000000020000000114575976EAF28003C00400040E080C70081C040863000322000803440200000814A04C30C0289A43C922454A922449A22449122549C244891469519200800239008092000010000002002040000000418C810001440120F20A000018482139555A5956555595999556A580022EE00000810048371A45060000C221A103011200C204B000C2F0580B011C84117A59557AD76655555595565555996A5695410405004100D0000018180880004400080289208604111880008584240002080000FF010000000100000001000000010000002C8898D78002083118060D00012840009403141400200460800002000042600A020200000440559A5559566556955555410600000218590444408821025105140000001080801C8A80004009462122858214FF01000000010000000100000001000000010000000100000033344284ADD480025600029490022C0806014084A044000520000048201A400001280C0A810924025655555655555A955555559B02800216081690C0200082011102209000000C10422061400091210D0008522423100C6DD55A6555655959965556591541057010884200902000640448001011288021A00400348000888600004850003000FF0100000001000000010000000100000001000000050C2BD1D4800201100020004624000120C104020004A20C4060CEC25129809C00520060001B98995995565B9799D55566E55956154107D1000014C3850083860022045D02090800E8004000000010CC0680B1C9084180FF01000000010000000100000001000000010000000100000001000000060D19465D63FA800304A008400C2B0C0C42104060240001445903AAA88630200008C28462010300405292244992244992245DA2689A224561B2445192240941020003000000C1C084005000000810B00402A86044001010000D81002091C80800FF0100000002000000B3F2800206034208804090000103802080A0763061010010080000114AB12459922253A156555555559566959579D6D5A595268003180500004A099C40000D40C84C1194800AE36A28295690E531A88100206D010C8B922C99922449A224A4A22AA93251A4362E529424919630519224498002140631900404850B100840824040D00205224209064839900500000300010082A965656655565B65595955959595800290053174E10D00288800009101863000C30089016296E01C00100033340C2440669555B75565556959A556596655D5655A80036610A41425030048EEE683190C035A006BD99D6A3E246D4F02C004C0029808B449324549CA2451A44C49922889A22849A64453A229CE962492158ACA2425499224493280030906040042800101CA88203018863B48420054140C0433490001C11851CC41084A92444992248A96640BC3244B922489A228499228569249800280182100101270040358400108104435C400420B010C0110001044312010B205555955AA5565A565695D5595D5558003A21371362F80A03B88032C20AE5ECF1924623C0D2C337FB559B03500866256AB4A9294D1942C92925089A22C4992645A96F451A2250995688C95444AA6E551C4284A942C8B9424CB124542022C00544805014014000805501845410050010490505C50400000002240101007110286008A4266002D343840600100310021050C0F0000000202040115415102FF0100000001000000C2CB80030591804260412A148108243040A1801386C1D602B37709E24FB477141082847C8A92244A924449B2245122250913298A42254C122D4B92244A94685314259992248103080200002000000002044A120004208202022024E2830042449F0214080080A34992244992245A94246312258992248B12008C501C8064A204084016CA138408150A06414A023385CC18B882D4221242038003E935AE71716E44869E2CEC084202508CA197C016C005B1761E60C101245A30900BAB2555B6244CB44549222951924849922C4C32258A144949A4384A92A811B3444992254A0480031F417E0C29D08121241D46083C630D6921014A0000080180006482019000C54049962489922461123251142951B264999228519224499426491225800315D62E4E404001641939CED4CC90C3522254240A08020401005000102214049289B2245192384912254C922463E4644B9A444B922449A42449922451008003A141021180787C040522062A01B108AA2082F0020982004094A080840C0608B34992245132454998284A92954992648A122589A24449122949928003040016251EB957C5412038014446440C05309420000201010102052040A000908992245942454A922489A2284AA22C89B2284992444992008003002201202A4090FCF43816A73242168541008918757091083023966124256E2D89923009936899924914C3240B93247112479192444C9224511425931226C992248003F94861394C18157C0A45B0045106E218440005502240418084200D882C3C0E384A122549922849942C4992248A94854A122559942849B224899244519224C98003000010020082040000881810040202C4832804B0083D69406C50B12D5E9A8489CA94644912654AA4244994449B92954992254A126589A22480027366008CB01DA1012A638168AE544201B1080A0C81200210481885041805344C65595565DA559699D55DA5D55595755555575955800301901E15001000000101A6648081444108102B110749480301811027800443224914499192244B122551A2246993244996444912294A9280030800915840AA092DB10346854804551E0960E844F2365A2CCCD10A6110A44A4E5992444A12515BC4248A92249AA22449944C9192484A14A94A9224499C2449962489928003D055AAC0A0C0543C0C727100A38840000029A090D04440BD1CCA4848051209014A922451922C89922492A2294992444992244A922889982849142A4BA42580034A5040BB87393F740C152CB8188034555269057BC5780E2A09994C0C600010000BA3288A1A2692322549942459924989A254CB222D89522BB2944449A24449922453160580031228C1F6145CC40325F1D0A640A61001A8681B0CFB8E446B1805BC102940235989926554C424D192E44998488A9A64894645494A25A1B22C49942491182D4A94244BB225B48003494FB8C321550000408E24E9ED41E3CC11011904040904021120101E8A02264991922449A62449222989A22451A64C4A92248A922491922892126E49C42449800340C119081C20CC1B0306C2888401828E481CD0A8758F23390304008101E9C9754A92484994644AA2345192244992284992284B522549122549A228D1148553B225810380006038A0405030042304084000200886015030240030320180448000CA04C04992245112664B22294912454A122551922451E069244E9502C0F4088C00806098860298D540943CC12A05000210402804CC408003484DA1321407C0558070040580B0135A8B4616245102B5A1A84831CA09985338531829899A2869B22549922C49B24449E44C51A4449194840AB52449B624C9C244014203481000800048040002650093000610004102961001015940048100410000010610510900A48006818C1294000110200000000053000881117015425000800000FF01000000020000000100000090A4F48003531B6120421041011C94E47804035D2B120D42A2E412C1AA291003C50310355551142559142D59A42452A4449212494922264FA42851946451A22C59AC24499844800366019E9C6E4D0B22C042A040002C1DB50054446D4D2818218A805108928218824B94288916A54992286112254A182A92A24891A2684992248A122A53A224499280038019B10444800A8140921B2841BF2E164593C4880355BC914265642908A3B0254A922449B224899232D194488AB68451124559422D919A2C491225499628521449910080032A835571550BFE4890A35B142B26078B2C55A33201B1C0084617D16340B7DB754C922992922C8992488AB2244D122992A24E49B664999445099324219344D2A35049C2245292284E1A66810330082018E02440803121080480000080C040008500218C4618081068200000C851A42C62A2644A92244992284B9424499264012101F160000C2C5821580B38598276320EB702540184417E034400324121E0420400506A18040A4002080010000008200C6400009400011940810011880085001808AD0450004000001008001000002010014C00101C0000485C800144011D1050FF020000000100000001000000010000005E5F61628003A00C640D34C00025D4003968C8020260181CA40A11080001C0B4030A03AC58968C92254A92244992284A944489A24449922449A22449B44449922801800313400200548191190C08844488000850055701656955411C04838102910D18494A92449292445112254A92444AA224C9942C89922449A22C69742580030CF01C149A4300080971228018E0055A0246DBAA8404B1F0B5A86177A02140EB89942451922451242549922449A2A4493625D4922449924C899444491425E192688A068003DA30F5536F7CBC1B0AD84B380B100B90B00115602C00180C021030000032100D519224499624AEA44569926589966449A34451342989942489B22449122549926880033560690308A02000055000E08991302AF8476F8C998C458DD3B1B0E0B0C0601449A2244A12294994259116269A9828891825499228C9942449A2249122254C944889800345140A25C50B00020041A0C30482206AA0823A04040877D245ACCB634917D0B451962549922449A44449A22449A6255292249213A549B24D522649622445D1968003C02218728C3C2A945AEF478041A6C0864A1DD171265543C5D7A4CF01335EAD8E62942449942411A5940A43458992284914494912254AC4855992344A92244D92304A22AEC922A5CC9424D2410B2880CA13142600084649004840201C844600044043816822104560000104008A020101010101010101010104072D5B636E7E8A929ABD8003A02620344421E102A1005189400801308A8100602A0104242E9E2320005108684992245194248A924451944849922449A224099350D92429098003880072818510D042C2250C9180C14102AA8042202543056201003001CD4430844A122949B2444FA22851242D51B4486992284A1425992425C9128003001D210C82A49000291881304C20354C4D10468B08018803884010390C71016549962449A2444992254992256192644992648916254992248A9228800300A036C030B0592088088A4860480237041045C28119423810000870800301214CA26851123151922449924C49B244514246D192244A92248A42093120001012402A90100500080114762C00500080E80410801040444580021040D1603400C0530006042944E38046003014021410D43010010203801101850013FF010000000100000001000000010000000100000001000000010000000100000002000000A6A9AFB3CACDE3ECF780046D00408DB199105C6547009C300111068A100315E94244440500412B18D7612131122112231214124123121211111112112112522719111222511112321513111121111141311111110280024C900028040400009811841012008042080165910A32401A11C90811046125015A9559665565565765559A95D679028004000C02B28261D2070F07940788D3130001F4D6C651AD810200022048401800441113123121119411112215112122113121113112113211113212412133111145111321211111118103000001000030008000301400013B0A8121003402000040CF171A0E82202024104994244996244992254B944999986449B2248024820600408041C185206126714E400482147021C640F802043174800C1383800325A0F2881460D8DA6B80897E70C021CEB269C91154CD182280425468C0029061493225D1A62409972849A224C9CA244992248992244AA2284916268A162559A42849920C80042313755A161C2241CC01A42810EE960000508F7540C03402B2810488524D052613121112331144121112121115412121213282331233211114121111321111131311136111122121111111800278605A171D00010800A24042E8110488040044C20AEF220AB0523A84002C08019955D969695E55559F956575E656659555558003B04A0180C2420C004180004804041000301020848016004C34042600144047204992444A9224CAA4244A92249122254AB228A1A480021500A00302105715B69398951E9A5955575965DA566551"),
            22630
        );

        var vals = new (byte[] compressed, int length)[100_000];
        for (var i = 0; i < vals.Length; i++) vals[i] = val;

        Parallel.ForEach(vals, new() { MaxDegreeOfParallelism = 1 },
            (v, _) =>
            {
                var res = Decompress(v.compressed, v.length, TurboPFor.p4nd1dec256v32);
                //Assert.That(AscListHelper.IsStrictlyAscending(res));
            }
        );
    }

    private static IEnumerable<int> RandomIncreasingRange(Random random, int length, int maxDelta)
    {
        var value = 0;
        for (var i = 0; i < length; i++)
        {
            value += random.Next(maxDelta);
            yield return value;
        }
    }

    private unsafe delegate nuint CompressFunc(int* @in, nuint n, byte* @out);

    private unsafe delegate nuint DecompressFunc(byte* @in, nuint n, int* @out);

    private unsafe delegate byte* CompressBlockFunc(int* @in, int n, byte* @out, int start);

    private unsafe delegate byte* DecompressBlockFunc(byte* @in, int n, int* @out, int start);

    private static unsafe byte[] Compress(int[] values, CompressBlockFunc compressFunc, int deltaStart = 0)
    {
        var buffer = new byte[values.Length * sizeof(int) + 1024];

        int resultLength;
        fixed (int* inputPtr = values)
        fixed (byte* resultPtr = buffer)
        {
            var endPtr = compressFunc(inputPtr, values.Length, resultPtr, deltaStart);
            resultLength = (int)(endPtr - (long)resultPtr);
        }

        //TestContext.Out.WriteLine($"Compressed: {resultLength} bytes");
        return buffer[..resultLength];
    }

    private static unsafe int[] Decompress(byte[] data, int count, DecompressBlockFunc decompressFunc, int deltaStart = 0)
    {
        var buffer = new int[count + 1024];

        fixed (byte* inputPtr = data)
        fixed (int* resultPtr = buffer)
        {
            var endPtr = decompressFunc(inputPtr, count, resultPtr, deltaStart);
        }

        return buffer[..count];
    }

    private static unsafe byte[] Compress(int[] values, CompressFunc compressFunc)
    {
        var buffer = new byte[values.Length * sizeof(int) + 1024];

        int resultLength;
        fixed (int* inputPtr = values)
        fixed (byte* resultPtr = buffer)
        {
            resultLength = (int)compressFunc(inputPtr, (nuint)values.Length, resultPtr);
        }

        //TestContext.Out.WriteLine($"Compressed: {resultLength} bytes");
        return buffer[..resultLength];
    }

    private static unsafe int[] Decompress(byte[] data, int count, DecompressFunc decompressFunc)
    {
        var buffer = new int[count];

        fixed (byte* inputPtr = data)
        fixed (int* resultPtr = buffer)
        {
            _ = decompressFunc(inputPtr, (nuint)count, resultPtr);
        }

        return buffer[..count];
    }
}
