// SPDX-FileCopyrightText: 2025 Demerzel Solutions Limited
// SPDX-License-Identifier: LGPL-3.0-only

using System;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;
using Nethermind.Core.Crypto;
using Nethermind.Int256;

namespace Nethermind.Core;

public readonly struct AccountStruct : IEquatable<AccountStruct>
{
    private static readonly AccountStruct _totallyEmpty = Account.TotallyEmpty.ToStruct();
    public static ref readonly AccountStruct TotallyEmpty => ref _totallyEmpty;

    private readonly UInt256 _nonce = default;
    public readonly ValueHash256 CodeHash = Keccak.OfAnEmptyString.ValueHash256;
    private readonly ValueHash256 _storageRoot = Keccak.EmptyTreeHash.ValueHash256;

    public AccountStruct(in UInt256 nonce, in UInt256 balance, in ValueHash256 storageRoot, in ValueHash256 codeHash)
    {
        Balance = balance;
        _nonce = nonce;
        CodeHash = codeHash;
        _storageRoot = storageRoot;
    }

    public AccountStruct(in UInt256 nonce, in UInt256 balance)
    {
        Balance = balance;
        _nonce = nonce;
    }

    public AccountStruct(in UInt256 balance)
    {
        Balance = balance;
    }

    public bool HasCode => CodeHash != Keccak.OfAnEmptyString.ValueHash256;

    public bool HasStorage => _storageRoot != Keccak.EmptyTreeHash.ValueHash256;

    public UInt256 Nonce => _nonce;
    public readonly UInt256 Balance;
    public ValueHash256 StorageRoot => _storageRoot;
    public bool IsTotallyEmpty => IsEmpty && IsStorageEmpty;
    public bool IsEmpty => Balance.IsZero && Nonce.IsZero && CodeHash == Keccak.OfAnEmptyString.ValueHash256;
    public bool IsContract => CodeHash != Keccak.OfAnEmptyString.ValueHash256;
    public bool IsStorageEmpty => _storageRoot == Keccak.EmptyTreeHash.ValueHash256;
    public bool IsNull
    {
        get
        {
            // The following branchless code is generated by the JIT compiler for the IsNull property on x64
            //
            // Method Nethermind.Core.AccountStruct:get_IsNull():bool:this (FullOpts)
            // G_M000_IG01:
            //        vzeroupper
            //
            // G_M000_IG02:
            //        vmovups  ymm0, ymmword ptr [rcx]
            //        vpor     ymm0, ymm0, ymmword ptr [rcx+0x20]
            //        vpor     ymm0, ymm0, ymmword ptr [rcx+0x40]
            //        vpor     ymm0, ymm0, ymmword ptr [rcx+0x60]
            //        vptest   ymm0, ymm0
            //        sete     al
            //        movzx    rax, al
            //
            // G_M000_IG03:                ;; offset=0x0021
            //        vzeroupper
            //        ret
            // ; Total bytes of code: 37

            return (Unsafe.As<UInt256, Vector256<byte>>(ref Unsafe.AsRef(in Balance)) |
                    Unsafe.As<UInt256, Vector256<byte>>(ref Unsafe.AsRef(in _nonce)) |
                    Unsafe.As<ValueHash256, Vector256<byte>>(ref Unsafe.AsRef(in CodeHash)) |
                    Unsafe.As<ValueHash256, Vector256<byte>>(ref Unsafe.AsRef(in _storageRoot))) == default;
        }
    }

    public bool Equals(AccountStruct other)
    {
        return _nonce == other.Nonce &&
               Balance == other.Balance &&
               CodeHash == other.CodeHash &&
               _storageRoot == other._storageRoot;
    }

    public AccountStruct WithChangedBalance(in UInt256 newBalance)
    {
        return new(Nonce, newBalance, _storageRoot, CodeHash);
    }

    public AccountStruct WithChangedNonce(in UInt256 newNonce)
    {
        return new(newNonce, Balance, _storageRoot, CodeHash);
    }

    public AccountStruct WithChangedStorageRoot(Hash256 newStorageRoot)
    {
        return new(Nonce, Balance, newStorageRoot, CodeHash);
    }

    public AccountStruct WithChangedCodeHash(Hash256 newCodeHash)
    {
        return new(Nonce, Balance, _storageRoot, newCodeHash);
    }

    public static bool operator ==(AccountStruct? left, AccountStruct? right)
    {
        if (left is not null)
        {
            return left.Equals(right);
        }
        return right is null;
    }
    public static bool operator !=(AccountStruct? left, AccountStruct? right) => !(left == right);
    public override bool Equals(object? obj) => Equals(obj as AccountStruct?);
    public bool Equals(AccountStruct? other)
    {
        if (other is not { } value) return false;

        return Nonce == value.Nonce &&
               Balance == value.Balance &&
               CodeHash == value.CodeHash &&
               _storageRoot == value._storageRoot;
    }
    public override int GetHashCode() => (int)BitOperations.Crc32C((uint)CodeHash.GetHashCode(), (ulong)Nonce.GetHashCode() << 8 | (uint)Balance.GetHashCode()) ^ StorageRoot.GetHashCode();
}
