// SPDX-FileCopyrightText: 2024 Demerzel Solutions Limited
// SPDX-License-Identifier: LGPL-3.0-only

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace Nethermind.Serialization.FastRlp.Generator;

[AttributeUsage(AttributeTargets.Class)]
public sealed class RlpSerializable : Attribute;

/// <summary>
/// A source generator that finds all records with [RlpSerializable] and
/// generates an abstract RlpConverter class with a Read method.
/// </summary>
[Generator]
public sealed class RlpSourceGenerator : IIncrementalGenerator
{
    private const string Version = "0.1";
    private const string GeneratedCodeAttribute = $"""[GeneratedCode("{nameof(RlpSourceGenerator)}", "{Version}")]""";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (s, _) => s is RecordDeclarationSyntax,
            transform: static (ctx, _) => (RecordDeclarationSyntax)ctx.Node
        );

        var compilation = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(compilation, Execute);
    }

    private void Execute(SourceProductionContext context,
        (Compilation Compilation, ImmutableArray<RecordDeclarationSyntax> RecordsDeclarationSyntaxes) p)
    {
        // For each record with the attribute, generate the RlpConverter class
        foreach (var recordDecl in p.RecordsDeclarationSyntaxes)
        {
            // Check if the record has the [RlpSerializable] attribute
            SemanticModel semanticModel = p.Compilation.GetSemanticModel(recordDecl.SyntaxTree);
            ISymbol? symbol = semanticModel.GetDeclaredSymbol(recordDecl);
            if (symbol is null) continue;

            // If not, skip the record
            var attributes = symbol.GetAttributes();
            if (!attributes.Any(a =>
                    a.AttributeClass?.Name == nameof(RlpSerializable) ||
                    a.AttributeClass?.ToDisplayString() == nameof(RlpSerializable)))
            {
                continue;
            }

            // Extract the `using` statements from the file containing the record
            var usingDirectiveSyntaxes = recordDecl
                .SyntaxTree
                .GetRoot()
                .DescendantNodes()
                .OfType<UsingDirectiveSyntax>()
                .Select(syntax => syntax.Name!.ToString());

            // Extract the record name with namespace if needed
            var recordName = symbol.Name;
            var fullTypeName = symbol.ToDisplayString();

            // Gather recursively all members that are fields or primary constructor parameters
            // so we can read them in the same order they are declared.
            var parameters = GetRecordParameters(recordDecl);

            // Build the converter class source
            var generatedCode = GenerateConverterClass(usingDirectiveSyntaxes, fullTypeName, recordName, parameters);

            // Add to the compilation
            context.AddSource($"{recordName}RlpConverter.g.cs", SourceText.From(generatedCode, Encoding.UTF8));
        }
    }

    /// <summary>
    /// Gathers the record’s primary constructor parameters and public fields/properties
    /// in the order they appear in the record declaration.
    /// </summary>
    private static List<(string Name, string TypeName)> GetRecordParameters(RecordDeclarationSyntax recordDecl)
    {
        List<(string, string)> parameters = [];

        // Primary constructor parameters
        if (recordDecl.ParameterList is not null)
        {
            foreach (var param in recordDecl.ParameterList.Parameters)
            {
                var paramName = param.Identifier.Text;
                var paramType = param.Type?.ToString() ?? "object";
                parameters.Add((paramName, paramType));
            }
        }

        return parameters;
    }

    private static string GenerateConverterClass(
        IEnumerable<string> usingDirectives,
        string fullTypeName,
        string recordName,
        List<(string Name, string TypeName)> parameters)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.CodeDom.Compiler;");
        sb.AppendLine("using Nethermind.Serialization.FastRlp;");
        sb.AppendLine("using Nethermind.Serialization.FastRlp.Instances;");
        foreach (var usingDirective in usingDirectives)
        {
            sb.AppendLine($"using {usingDirective};");
        }
        sb.AppendLine();
        sb.AppendLine("namespace Nethermind.Serialization.FastRlp.Derived;");
        sb.AppendLine("");
        sb.AppendLine(GeneratedCodeAttribute);
        sb.AppendLine($"public abstract class {recordName}RlpConverter : IRlpConverter<{fullTypeName}>");
        sb.AppendLine("{");

        // `Write` method
        sb.AppendLine($"public static void Write(ref RlpWriter w, {fullTypeName} value)");
        sb.AppendLine("{");
        sb.AppendLine("w.WriteList((ref RlpWriter w) => ");
        sb.AppendLine("{");

        foreach (var (name, _) in parameters)
        {
            sb.AppendLine($"w.Write(value.{name});");
        }
        sb.AppendLine("});");
        sb.AppendLine("}");

        // `Read` method
        sb.AppendLine($"public static {fullTypeName} Read(ref RlpReader r)");
        sb.AppendLine("{");
        sb.AppendLine("return r.ReadList(static (scoped ref RlpReader r) =>");
        sb.AppendLine("{");

        foreach (var (name, typeName) in parameters)
        {
            var readCall = MapTypeToReadCall(typeName);
            sb.AppendLine($"var {name} = r.{readCall};");
        }

        sb.Append($"return new {fullTypeName}(");
        for (int i = 0; i < parameters.Count; i++)
        {
            sb.Append(parameters[i].Name);
            if (i < parameters.Count - 1) sb.Append(", ");
        }
        sb.AppendLine(");");

        sb.AppendLine("});");
        sb.AppendLine("}");
        sb.AppendLine("}");

        sb.AppendLine();
        sb.AppendLine(GeneratedCodeAttribute);
        sb.AppendLine($"public static class {recordName}Ext");
        sb.AppendLine("{");
        sb.AppendLine($"public static {fullTypeName} Read{recordName}(this ref RlpReader reader) => {recordName}RlpConverter.Read(ref reader);");
        sb.AppendLine($"public static void Write(this ref RlpWriter writer, {fullTypeName} value) => {recordName}RlpConverter.Write(ref writer, value);");
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Map the type name to the appropriate Read method on the `RlpReader`
    /// Extend this mapping for more types as needed.
    /// </summary>
    private static string MapTypeToReadCall(string typeName)
    {
        return typeName switch
        {
            "byte[]" or "System.Byte[]" or "Span<byte>" or "System.Span<byte>" or "System.ReadOnlySpan<byte>" => "ReadBytes()",
            "int" => "ReadInt32()",
            _ => $"Read{typeName.Capitalize()}()"
        };
    }
}

public static class StringExt
{
    public static string Capitalize (this string str) => str[0].ToString().ToUpper() + str[1..];
}
