name: Sync Supported Chains

on:
  workflow_run:
    workflows: ["Publish Docker image"]
    branches: [release/*]
    types:
      - completed

  schedule:
    - cron: "0 0 1 * *"  # Run regular and superchain networks on first day of month
    - cron: "0 0 * * 0"  # Run random superchain subset on Sundays and regular chains
    
  workflow_dispatch:
    inputs:
      nethermind_image:
        description: "Docker image to be used by action"
        default: ""
        required: false
      network_filter:
        description: "Filter networks by name (partial or full match)"
        default: ""
        required: false
      network_type:
        description: "Type of networks to run (regulars or superchain)"
        default: "regular"
        required: true
        type: choice
        options:
          - regular
          - superchain

env:
  DOTNET_SYSTEM_CONSOLE_ALLOW_ANSI_COLOR_REDIRECTION: "1"
  TERM: xterm

jobs:
  setup-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          path: nethermind
          ref: ${{ github.event.workflow_run.head_branch || github.ref_name || 'master' }}
      - name: Set Matrix
        id: set-matrix
        run: |
          # Set network type and load appropriate matrix
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # For manual runs, use the specified network type
            echo "NETWORK_TYPE=${{ github.event.inputs.network_type }}" >> $GITHUB_ENV
            if [ "${{ github.event.inputs.network_type }}" = "superchain" ]; then
              echo "Loading superchains matrix for workflow_dispatch"
              matrix=$(cat nethermind/scripts/workflow_config/sync_superchains_matrix.json)
            else
              echo "Loading regular networks matrix for workflow_dispatch"
              matrix=$(cat nethermind/scripts/workflow_config/sync_testnets_matrix.json)
            fi
          elif [ "${{ github.event_name }}" = "schedule" ]; then
            if [ "${{ github.event.schedule }}" = "0 0 1 * *" ]; then
              # First day of month: Run both regular and superchain networks
              echo "NETWORK_TYPE=superchain" >> $GITHUB_ENV
              echo "Loading both matrices for monthly run"
              regular_matrix=$(cat nethermind/scripts/workflow_config/sync_testnets_matrix.json)
              superchain_matrix=$(cat nethermind/scripts/workflow_config/sync_superchains_matrix.json)
              matrix=$(echo "$regular_matrix" "$superchain_matrix" | jq -s 'add')
            else
              # Sunday runs: Regular networks + random subset of superchain networks
              echo "NETWORK_TYPE=superchain" >> $GITHUB_ENV
              echo "Loading regular networks and random superchain subset for weekly run"
              regular_matrix=$(cat nethermind/scripts/workflow_config/sync_testnets_matrix.json)
              superchain_matrix=$(cat nethermind/scripts/workflow_config/sync_superchains_matrix.json)
              random_count=$(( ( RANDOM % 6 ) + 5 ))
              echo "Selecting $random_count random superchain networks"
              superchain_subset=$(echo "$superchain_matrix" | jq --arg count "$random_count" 'shuffle | .[:($count | tonumber)]')
              matrix=$(echo "$regular_matrix" "$superchain_subset" | jq -s 'add')
            fi
          else
            # Default to regular for workflow_run triggers
            echo "NETWORK_TYPE=regular" >> $GITHUB_ENV
            echo "Loading regular networks matrix for workflow_run"
            matrix=$(cat nethermind/scripts/workflow_config/sync_testnets_matrix.json)
          fi

          # Validate matrix is not empty
          if [ "$(echo "$matrix" | jq '. | length')" -eq 0 ]; then
            echo "Error: Matrix is empty"
            exit 1
          fi

          # Apply network filter if provided
          if [ -n "${{ github.event.inputs.network_filter }}" ]; then
            matrix=$(echo "$matrix" | jq --arg filter "${{ github.event.inputs.network_filter }}" '[.[] | select(.network | contains($filter))]')
          # On weekly runs, select random subset
          elif [ "${{ github.event.schedule }}" = "0 0 * * 0" ]; then
            random_count=$(( ( RANDOM % 6 ) + 5 ))
            echo "Running weekly test with $random_count random chains"
            matrix=$(echo "$matrix" | jq --arg count "$random_count" 'shuffle | .[:($count | tonumber)]')
          fi

          # Add runner_network field with shortened name for runner interactions
          # Format is: t-<run_id>-<network>, where run_id can be up to 20 chars
          # So we need to ensure: len("t-" + run_id + "-" + network) <= 32
          # This means network name should be: 32 - 2 - 20 - 1 = 9 chars max
          matrix_json=$(echo "$matrix" | jq -c '[ .[] | 
            . + { 
              "runner_network": (.network | 
                # First, replace any non-alphanumeric chars with hyphen
                gsub("[^a-zA-Z0-9]+"; "-") |
                # Then create a short but recognizable name
                split("-") | 
                # For each part, take first 3 chars, join with hyphens
                map(if length > 3 then .[0:3] else . end) |
                join("-") |
                # Ensure total length <= 9
                if length > 9 then
                  .[0:9] | rtrimstr("-")
                else
                  .
                end
              ) 
            } 
          ]')

          # Set matrix output and validate it
          echo "Matrix content: $matrix_json"
          echo "matrix=$matrix_json" >> $GITHUB_OUTPUT
          echo "Matrix length: $(echo "$matrix_json" | jq '. | length')"

          # Print network name mappings for reference
          echo "Network name mappings:"
          echo "$matrix_json" | jq -r '.[] | "\(.network) -> \(.runner_network)"'

  create_a_runner:
    needs: [setup-matrix]
    strategy:
      fail-fast: false
      matrix:
        config: ${{fromJson(needs.setup-matrix.outputs.matrix)}}
    runs-on: ubuntu-latest
    outputs:
      runner_label: ${{ steps.run-linode-action.outputs.runner_label }}
      machine_id: ${{ steps.run-linode-action.outputs.machine_id }}
    steps:
      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass
        
      - name: Create a Runner
        id: run-linode-action
        uses: kamilchodola/linode-github-runner/.github/actions/linode-machine-manager@main
        with:
          linode_token: ${{ secrets.LINODE_TOKEN }}
          github_token: "${{ secrets.REPOSITORY_DISPATCH_TOKEN }}"
          action: "create"
          runner_label: t-${{ github.run_id }}-${{ matrix.config.runner_network }}
          root_password: ${{ secrets.LINODE_ROOT_PASSWORD }}
          machine_type: "${{ matrix.config.agent }}"
          image: "linode/ubuntu24.04"
          tags: "core, self-hosted, dynamic"
          organization: "NethermindEth"
          repo_name: "nethermind"
          blocked_ports: "8545,8546,8551,8552"
  
  sync-chain:
    needs: [setup-matrix, create_a_runner]
    strategy:
      fail-fast: false
      matrix:
        config: ${{fromJson(needs.setup-matrix.outputs.matrix)}}
        
    name: "Run sync of ${{ matrix.config.network }} chain"
    runs-on: t-${{ github.run_id }}-${{ matrix.config.runner_network }}
    timeout-minutes: ${{ matrix.config.timeout }}
    
    steps:
      - name: Authenticate App
        id: gh-app
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          repositories: "nethermind,post-merge-smoke-tests"
          
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          clean: true
          ref: ${{ github.event.workflow_run.head_branch || github.ref_name || 'master' }}
          
      - name: Checkout tests repository
        uses: actions/checkout@v4
        with:
          repository: NethermindEth/post-merge-smoke-tests
          path: tests
          token: ${{ steps.gh-app.outputs.token }}
          clean: true

      - name: Installing requirements
        run: |
          sudo apt-get update
          sudo apt-get install -y make build-essential jq screen lshw dmidecode fio zip

      - name: Setup Go environment
        uses: actions/setup-go@v5
        with:
          go-version: 'stable'
          check-latest: true
          cache: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.X"

      - name: Install Sedge environment
        run: |
          echo "Downloading sedge sources..."
          # Use core-superchains branch for superchain networks, core for regular
          if [ "${{ env.NETWORK_TYPE }}" = "superchain" ] || [[ "${{ matrix.config.network }}" == base-* || "${{ matrix.config.network }}" == op-* || "${{ matrix.config.network }}" == world-* ]]; then
            git clone https://github.com/NethermindEth/sedge.git sedge --branch core-superchains --single-branch
          else
            git clone https://github.com/NethermindEth/sedge.git sedge --branch core --single-branch
          fi
          echo "Sources downloaded."
          cd sedge
          echo "Building sedge..."
          make compile

      - name: Run Sedge
        working-directory: sedge
        run: |
          docker_image=""
          network="${{ matrix.config.network }}"
          
          if [ -z "${{ inputs.nethermind_image }}" ]; then
            REF_NAME=${{ github.event.workflow_run.head_branch || github.ref_name || 'master' }}
            CLEAN_REF=$(echo "${REF_NAME/refs\/heads\//}")
            if [[ $CLEAN_REF == release/* ]]; then
              CLEAN_REF=$(echo "$CLEAN_REF" | sed 's/[^a-zA-Z0-9._-]/-/g')
              docker_image="nethermindeth/nethermind:$CLEAN_REF"
            else
              docker_image="nethermindeth/nethermind:master"
            fi
          else
            docker_image="${{ inputs.nethermind_image }}"
          fi
          
          echo 'Generating sedge docker...'
          ./build/sedge deps install

          # Handle network type detection and setup
          if [ "${{ env.NETWORK_TYPE }}" = "superchain" ] || ([[ "$network" == *-mainnet || "$network" == *-sepolia ]]); then
            # Superchain network
            if [[ "$network" == *mainnet* ]]; then
              CONSENSUS_URL="${{ secrets.MAINNET_CONSENSUS_URL }}"
              EXECUTION_URL="${{ secrets.MAINNET_EXECUTION_URL }}"
            elif [[ "$network" == *sepolia* ]]; then
              CONSENSUS_URL="${{ secrets.SEPOLIA_CONSENSUS_URL }}"
              EXECUTION_URL="${{ secrets.SEPOLIA_EXECUTION_URL }}"
            else
              echo "Unknown network"
              exit 1
            fi

            # Extract superchain and network name
            IFS='-' read -r superchain network_name <<< "$network"
            if [ -z "$network_name" ]; then
              network_name="$superchain"
              superchain=""
            fi
            
            # Set environment variables
            export SUPERCHAIN="$superchain"
            export NETWORK="$network_name"

            mkdir -p execution-data-op/logs/configs
            mv ../tests/predefined_configs/customNLog.config execution-data-op/logs/configs/customNLog.config
            
            ./build/sedge generate \
            --logging none \
            -p $GITHUB_WORKSPACE/sedge \
            op-full-node \
            --op-execution opnethermind:$docker_image \
            --op-image op-node:us-docker.pkg.dev/oplabs-tools-artifacts/images/op-node:v1.10.3 \
            --map-all \
            --chain $SUPERCHAIN \
            --network $NETWORK \
            --consensus-url $CONSENSUS_URL \
            --execution-api-url $EXECUTION_URL \
            --el-op-extra-flag loggerConfigSource=/nethermind/data/logs/configs/customNLog.config \
            --el-op-extra-flag Sync.VerifyTrieOnStateSyncFinished=true \
            $extra_param
          elif [[ "$network" == taiko-* ]]; then
            if [[ "$network" == *alethia* ]]; then
              CONSENSUS_URL="${{ secrets.MAINNET_CONSENSUS_URL }}"
              EXECUTION_URL="${{ secrets.MAINNET_EXECUTION_URL }}"
              stripped_network="mainnet"
            elif [[ "$network" == *hekla* ]]; then
              CONSENSUS_URL="${{ secrets.HOLESKY_CONSENSUS_URL }}"
              EXECUTION_URL="${{ secrets.HOLESKY_EXECUTION_URL }}"
              stripped_network="holesky"
            else
              echo "Unknown network"
              exit 1
            fi

            mkdir -p execution-data-taiko/logs/configs
            mv ../tests/predefined_configs/customNLog.config execution-data-taiko/logs/configs/customNLog.config
            
            ./build/sedge generate \
            --logging none \
            -p $GITHUB_WORKSPACE/sedge \
            taiko-full-node \
            --l2-execution taiko-nethermind:$docker_image \
            --taiko-image taiko:us-docker.pkg.dev/evmchain/images/taiko-client:latest \
            --map-all \
            --network $stripped_network \
            --consensus-url $CONSENSUS_URL \
            --execution-api-url $EXECUTION_URL \
            --el-l2-extra-flag loggerConfigSource=/nethermind/data/logs/configs/customNLog.config \
            --el-l2-extra-flag Sync.VerifyTrieOnStateSyncFinished=true \
            $extra_param
          else
            mkdir -p execution-data/logs/configs
            mv ../tests/predefined_configs/customNLog.config execution-data/logs/configs/customNLog.config

            # Extract base network name (e.g. mainnet from hashkeychain-mainnet)
            IFS='-' read -r -a network_parts <<< "$network"
            base_network="${network_parts[-1]}"
            echo "Using base network: $base_network"
          
            ./build/sedge generate \
            --logging none \
            -p $GITHUB_WORKSPACE/sedge \
            full-node \
            -c ${{ matrix.config.cl }}:${{ matrix.config.cl_image }} \
            -e nethermind:$docker_image \
            --map-all \
            --no-mev-boost \
            --no-validator \
            --network $base_network \
            --el-extra-flag Sync.NonValidatorNode=true \
            --el-extra-flag Sync.DownloadBodiesInFastSync=false \
            --el-extra-flag Sync.DownloadReceiptsInFastSync=false \
            --el-extra-flag JsonRpc.EnabledModules=[Eth,Subscribe,Trace,TxPool,Web3,Personal,Proof,Net,Parity,Health,Rpc,Debug] \
            --el-extra-flag Sync.VerifyTrieOnStateSyncFinished=true \
            --el-extra-flag loggerConfigSource=/nethermind/data/logs/configs/customNLog.config \
            --el-extra-flag Sync.SnapSync=true \
            --checkpoint-sync-url=${{ matrix.config.checkpoint-sync-url }}
          fi          
          
          echo 'Running sedge...'
          ./build/sedge run -p $GITHUB_WORKSPACE/sedge

      - name: Wait for ${{ matrix.config.network }} to sync
        id: wait
        env:
          NETWORK: ${{ matrix.config.network }}
        run: |
          if [ "${{ env.NETWORK_TYPE }}" = "superchain" ]; then
            python scripts/waitForSyncSuperchains.py
          else
            python scripts/waitForSync.py
          fi

      - name: Get Nethermind Debug Logs
        if: failure()
        id: find-and-upload
        run: |      
          if [ "${{ env.NETWORK_TYPE }}" = "superchain" ] || [[ "${{ matrix.config.network }}" == base-* || "${{ matrix.config.network }}" == op-* || "${{ matrix.config.network }}" == world-* ]]; then
            cd execution-data-op/logs
          elif [[ "${{ matrix.config.network }}" == taiko-* ]]; then
            cd execution-data-taiko/logs
          else
            cd execution-data/logs
          fi
          ls
          log_file=$(find . -type f -name "*logs.txt" | head -n 1)
          echo "Found log file: $log_file"
          artifact_name=$(basename "$log_file" .txt)-${{ github.run_id }}
          zip "${artifact_name}.zip" "$log_file"
          echo "Compressed log file into ${artifact_name}.zip"
          echo "artifact_name=$artifact_name" >> $GITHUB_ENV
          echo "artifact_path=$(pwd)/${artifact_name}.zip" >> $GITHUB_ENV

      - name: Upload Nethermind Debug logs artifact
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.artifact_name }}
          path: ${{ env.artifact_path }}
          retention-days: 7
          
      - name: Get Consensus Logs
        if: always() && matrix.config.network != 'joc-mainnet' && matrix.config.network != 'joc-testnet' && matrix.config.network != 'linea-mainnet' && matrix.config.network != 'linea-sepolia'
        run: |
          network="${{ matrix.config.network }}"
          if [ "${{ env.NETWORK_TYPE }}" = "superchain" ]; then
            # All superchains use the same container name
            docker logs sedge-consensus-op-l2-client
          elif [[ "$network" == taiko-* ]]; then
            docker logs sedge-consensus-taikodriver-client
          else
            docker logs sedge-consensus-client
          fi
          
      - name: Check size of DB 
        run: |
          du -h $GITHUB_WORKSPACE/sedge

      - name: Destroy VM
        if: always()
        id: run-linode-action
        uses: kamilchodola/linode-github-runner/.github/actions/linode-machine-manager@main
        with:
          linode_token: ${{ secrets.LINODE_TOKEN }}
          github_token: "${{ secrets.REPOSITORY_DISPATCH_TOKEN }}"
          action: "destroy-machine-async"
          runner_label: t-${{ github.run_id }}-${{ matrix.config.runner_network }}
          search_phrase: t-${{ github.run_id }}-${{ matrix.config.runner_network }}
          root_password: ${{ secrets.LINODE_ROOT_PASSWORD }}
          organization: "NethermindEth"
          repo_name: "nethermind"

  destroy_runner:
    needs: [setup-matrix, create_a_runner, sync-chain]
    if: always()
    strategy:
      fail-fast: false
      matrix:
        config: ${{fromJson(needs.setup-matrix.outputs.matrix)}}
    runs-on: ubuntu-latest
    steps:
      - name: Destroy VM (make sure is removed)
        uses: kamilchodola/linode-github-runner/.github/actions/linode-machine-manager@main
        continue-on-error: true
        with:
          linode_token: ${{ secrets.LINODE_TOKEN }}
          github_token: "${{ secrets.REPOSITORY_DISPATCH_TOKEN }}"
          action: "destroy-machine"
          runner_label: t-${{ github.run_id }}-${{ matrix.config.runner_network }}
          search_phrase: t-${{ github.run_id }}-${{ matrix.config.runner_network }}
          root_password: ${{ secrets.LINODE_ROOT_PASSWORD }}
          organization: "NethermindEth"
          repo_name: "nethermind"
          
      - name: Destroy Runner
        uses: kamilchodola/linode-github-runner/.github/actions/linode-machine-manager@main
        with:
          linode_token: ${{ secrets.LINODE_TOKEN }}
          github_token: "${{ secrets.REPOSITORY_DISPATCH_TOKEN }}"
          action: "destroy-runner"
          runner_label: t-${{ github.run_id }}-${{ matrix.config.runner_network }}
          search_phrase: t-${{ github.run_id }}-${{ matrix.config.runner_network }}
          root_password: ${{ secrets.LINODE_ROOT_PASSWORD }}
          organization: "NethermindEth"
          repo_name: "nethermind"
  trigger_tests:
    needs: [setup-matrix, create_a_runner, sync-chain, destroy_runner]
    if: success()
    runs-on: ubuntu-latest
    steps:
      - name: Authenticate App
        id: gh-app
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          repositories: "nethermind,post-merge-smoke-tests"
          
      - name: Trigger notification action on test repo
        if: startsWith(github.event.workflow_run.head_branch, 'release/')
        continue-on-error: true
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: receive-push-notification.yml
          repo: NethermindEth/post-merge-smoke-tests
          ref: "main"
          token: "${{ steps.gh-app.outputs.token }}"
          inputs: '{
            "nethermind_branch": "${{ github.event.workflow_run.head_branch }}"
          }'
